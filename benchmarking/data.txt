Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

Node had a watershed year in 2010, and it's shaping up to be as popular as Ruby on Rails among developers. Since the framework was built for the commonly used JavaScript, the barriers to entry are remarkably low, and the reasons for choosing Node to build apps -- especially low-latency, real-time apps -- are increasingly compelling.

Then there's the community. The Ruby community has been criticized for being exclusive and harsh. The Node community provides a welcome contrast and embodies the spirit of many other open-source communities. Again, the framework's JavaScript roots means that it appeals to the less hacker-ish web designer who might be dabbling in web app development as much as it appeals to longtime, hardcore hackers who simply want a better way to build real-time apps.

We asked each of the three startups giving demos at Joyent: Why choose Node?

The common wisdom among many developers is that there is no single right language or framework that should and must be used for all web apps. But based on what we heard from these startups, Node is increasingly being seen as a "best solution" for a certain type of application.

According to Tom Hughes-Croucher, a recent Joyent hire who is writing the first O'Reilly book on Node, “Node has popularized event-driven programming.” With event-driven programming, Hughes-Croucher explains, “The actual amount of resources you use is much smaller, and you can get a lot more out of fewer servers.”

Node is all about making event-driven, low-latency, concurrent apps. Erlang, the language that powers Facebook's chat server, uses the same model. Tornado, a concurrent server for Python that powers FriendFeed, was an attempt at this, too. But Node has one advantage over technologies like Erlang and Tornado: “None of that was too accessible,” says Hughes-Croucher. “Node takes a language people know very well -- Javascript -- and makes it available to do server programming, as well.”

In traditional languages and frameworks, the communication inside the app between the web server and the database is the most time-intensive part of the transaction. Node makes a much smaller footprint on your web server. It allocates web server resources on an as-needed basis, not pre-allocating a large chunk of resources for each user. For example, Apache might assign 8MB to a user, while Node assigns 8KB.

